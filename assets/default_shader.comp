#version 450

layout(set = 0, binding = 0, rgba8) uniform image2D result;

layout(set = 0, binding = 1) uniform GlobalUniformBuffer {
	vec4 camera_translation;
	mat4 camera_rotation;
} global_uniform;

struct Vertex {
		vec3 pos;
		vec3 color;
		vec2 texCoord;
};

/*MESH_DECL*/

/*NODE_DECL*/

/*RESOURCE_DECL*/

layout(binding = 2) readonly buffer vertex_buffer {
	Vertex vertices[];
};
layout(binding = 3) readonly buffer index_buffer {
	uint indices[];
};
layout(binding = 4) readonly buffer mesh_buffer {
	Mesh meshes[];
};
layout(binding = 5) readonly buffer node_buffer {
	Node nodes[];
};
layout(binding = 6) uniform sampler2D textures[/*TEXTURE_COUNT*/];


struct triangle3 {
	vec3 v1, v2, v3;
};

//https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm
bool ray_intersects_triangle(in vec3 ray_origin, 
                             in vec3 ray_vector, 
                             in triangle3 triangle,
                             inout vec3 out_intersection_point,
                             inout vec2 uv)
{
	//https://en.cppreference.com/w/cpp/types/climits
	float epsilon = 1.19209e-07;

	vec3 edge1 = triangle.v2 - triangle.v1;
	vec3 edge2 = triangle.v3 - triangle.v1;
	vec3 ray_cross_e2 = cross(ray_vector, edge2);
	float det = dot(edge1, ray_cross_e2);

	if (det > -epsilon && det < epsilon)
			return false;    // This ray is parallel to this triangle.

	float inv_det = 1.0 / det;
	vec3 s = ray_origin - triangle.v1;
	float u = inv_det * dot(s, ray_cross_e2);

	if (u < 0 || u > 1)
			return false;

	vec3 s_cross_e1 = cross(s, edge1);
	float v = inv_det * dot(ray_vector, s_cross_e1);

	if (v < 0 || u + v > 1)
			return false;

	// At this stage we can compute t to find out where the intersection point is on the line.
	float t = inv_det * dot(edge2, s_cross_e1);

	if (t > epsilon) // ray intersection
	{
			out_intersection_point = ray_origin + ray_vector * t;
			uv = vec2(u, v);
			return true;
	}
	else // This means that there is a line intersection but not a ray intersection.
			return false;
}

void main() {
	ivec2 resultDim = imageSize(result);
	vec2 uv = vec2(gl_GlobalInvocationID.xy) / resultDim;

	vec4 dir = normalize(vec4(0.5 - uv.x, uv.y, 3, 0)) * global_uniform.camera_rotation;
	vec3 intr;
	vec2 intr_uv;
	vec2 tex_uv;

	vec4 color = imageLoad(result, ivec2(gl_GlobalInvocationID.xy));
	color *= 0.9;
	color += vec4(uv, 0.0, 1.0) * 0.01;

	vec4 position = vec4(0, 0, 0, 1) + global_uniform.camera_translation;

	for (uint n = 0; n < nodes.length(); n++) {
		uint m = nodes[n].mesh_id;
		vec3 node_pos = nodes[n].position;
		uint vertex_offset = meshes[m].vertex_offset;
		uint index_offset = meshes[m].index_offset;
		uint index_size = meshes[m].index_size;
		for (uint i = index_offset; i < index_offset + index_size; i += 3) {
			uint v = i + vertex_offset;

			triangle3 t;
			t.v1 = vertices[vertex_offset + indices[v+0]].pos;
			t.v2 = vertices[vertex_offset + indices[v+1]].pos;
			t.v3 = vertices[vertex_offset + indices[v+2]].pos;

			if (ray_intersects_triangle(position.xyz + node_pos, dir.xyz, t, intr, intr_uv)) {
				vec2 u1 = vertices[vertex_offset + indices[v+0]].texCoord;
				vec2 u2 = vertices[vertex_offset + indices[v+1]].texCoord;
				vec2 u3 = vertices[vertex_offset + indices[v+2]].texCoord;

				tex_uv = vec2(0, 0);
				tex_uv = (1 - intr_uv.x - intr_uv.y) * u1;
				tex_uv += intr_uv.x * u2;
				tex_uv += intr_uv.y * u3;

				color = texture(textures[0], tex_uv) * (texture(textures[1], tex_uv) * 0.5 + 0.5);
				color.xyz = vec3(pow(color.x, 1/2.2), pow(color.y, 1/2.2), pow(color.z, 1/2.2));
			}
		}
	}

	color.a = 2.0;
	imageStore(result, ivec2(gl_GlobalInvocationID.xy), color);
}
