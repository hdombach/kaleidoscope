#version 450

layout(set = 0, binding = 0, rgba8) uniform image2D result;

/*VERTEX_DECL*/

/*BVNODE_DECL*/

/*NODE_DECL*/

/*RESOURCE_DECL*/

/*UNIFORM_DECL*/

layout(set = 0, binding = 1) uniform UniformBlock {
	ComputeUniform u;
} compute_uniform;

layout(binding = 2) readonly buffer vertex_buffer {
	Vertex vertices[];
};
layout(binding = 3) readonly buffer mesh_buffer {
	BVNode bvnodes[];
};
layout(binding = 4) readonly buffer node_buffer {
	Node nodes[];
};
layout(binding = 5) uniform sampler2D textures[/*TEXTURE_COUNT*/];
/*MATERIAL_BUFFERS*/

float PI = 3.14159265358979;

struct Triangle {
	vec3 v1, v2, v3;
};

/*MATERIAL_SRCS*/

// https://gist.github.com/DomNomNom/46bb1ce47f68d255fd5d
// returns (near, far)
vec2 intersect_aabb(vec3 ray_pos, vec3 ray_dir, vec3 box_min, vec3 box_max) {
    vec3 tmin = (box_min - ray_pos) / ray_dir;
    vec3 tmax = (box_max - ray_pos) / ray_dir;
    vec3 t1 = min(tmin, tmax);
    vec3 t2 = max(tmin, tmax);
    float tnear = max(max(t1.x, t1.y), t1.z);
    float tfar = min(min(t2.x, t2.y), t2.z);
    return vec2(tnear, tfar);
}

//https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm
bool ray_intersects_triangle(in vec3 ray_origin, 
                             in vec3 ray_vector, 
                             in Triangle triangle,
                             inout vec3 out_intersection_point,
                             inout vec2 uv)
{
	//https://en.cppreference.com/w/cpp/types/climits
	float epsilon = 1.19209e-07;

	vec3 edge1 = triangle.v2 - triangle.v1;
	vec3 edge2 = triangle.v3 - triangle.v1;
	vec3 ray_cross_e2 = cross(ray_vector, edge2);
	float det = dot(edge1, ray_cross_e2);

	if (det > -epsilon && det < epsilon)
			return false;    // This ray is parallel to this triangle.

	float inv_det = 1.0 / det;
	vec3 s = ray_origin - triangle.v1;
	float u = inv_det * dot(s, ray_cross_e2);

	if (u < 0 || u > 1)
			return false;

	vec3 s_cross_e1 = cross(s, edge1);
	float v = inv_det * dot(ray_vector, s_cross_e1);

	if (v < 0 || u + v > 1)
			return false;

	// At this stage we can compute t to find out where the intersection point is on the line.
	float t = inv_det * dot(edge2, s_cross_e1);

	if (t > epsilon) // ray intersection
	{
			out_intersection_point = ray_origin + ray_vector * t;
			uv = vec2(u, v);
			return true;
	}
	else // This means that there is a line intersection but not a ray intersection.
			return false;
}

bool intersect_mesh(vec3 ray_pos, vec3 ray_dir, uint m, inout uint debug, inout vec2 uv) {
	vec2 intr, tuv;
	uint prevm = 0;
	vec3 intr_point;
	float dist = 3.402823466e+38;
	bool result = false;

	while (m > 0) {
		if (bvnodes[m].type == BV_UNKNOWN) {
			return false;
		}

		if (bvnodes[m].type == BV_MESH) {
			Triangle t;

			debug++;
			intr = intersect_aabb(
				ray_pos,
				ray_dir,
				bvnodes[m].min_pos,
				bvnodes[m].max_pos);

			if (intr.x < intr.y && intr.x < dist) {
				debug += 1;
				if (bvnodes[m].lchild != -1) {
					uint tm = bvnodes[m].lchild;
					t.v1 = vertices[tm + 0].pos;
					t.v2 = vertices[tm + 1].pos;
					t.v3 = vertices[tm + 2].pos;
					if (ray_intersects_triangle(ray_pos, ray_dir, t, intr_point, tuv)) {
						float diff = length(intr_point - ray_pos);
						if (diff < dist) {
							dist = diff;
							vec2 uv1 = vertices[tm + 0].tex_coord;
							vec2 uv2 = vertices[tm + 1].tex_coord;
							vec2 uv3 = vertices[tm + 2].tex_coord;

							uv = (1 - tuv.x - tuv.y) * uv1;
							uv += tuv.x * uv2;
							uv += tuv.y * uv3;
						}
						result = true;
					}
				}
				if (bvnodes[m].rchild != -1) {
					uint tm = bvnodes[m].rchild;
					t.v1 = vertices[tm + 0].pos;
					t.v2 = vertices[tm + 1].pos;
					t.v3 = vertices[tm + 2].pos;
					if (ray_intersects_triangle(ray_pos, ray_dir, t, intr_point, tuv)) {
						float diff = length(intr_point - ray_pos);
						if (diff < dist) {
							dist = diff;
							vec2 uv1 = vertices[tm + 0].tex_coord;
							vec2 uv2 = vertices[tm + 1].tex_coord;
							vec2 uv3 = vertices[tm + 2].tex_coord;

							uv = (1 - tuv.x - tuv.y) * uv1;
							uv += tuv.x * uv2;
							uv += tuv.y * uv3;
						}
						result = true;
					}
				}
			}

			prevm = m;
			m = bvnodes[m].parent;
			continue;
		}

		if (bvnodes[m].type != BV_NODE) return false;

		if (prevm == bvnodes[m].parent) {
			debug++;
			intr = intersect_aabb(
				ray_pos,
				ray_dir,
				bvnodes[m].min_pos,
				bvnodes[m].max_pos);

			if (intr.x < intr.y && intr.x < dist) {
				prevm = m;
				m = bvnodes[m].lchild;
			} else {
				prevm = m;
				m = bvnodes[m].parent;
			}
		} else if (prevm == bvnodes[m].lchild) {
			prevm = m;
			m = bvnodes[m].rchild;
		} else if (prevm == bvnodes[m].rchild) {
			prevm = m;
			m = bvnodes[m].parent;
		}
	}
	return result;
}

void main() {
	ivec2 size = imageSize(result);
	vec2 uv = vec2(gl_GlobalInvocationID.xy) / vec2(size);

	vec4 dir = vec4(uv.x * 2.0 - 1.0, 1.0 - uv.y * 2.0, 2.0, 0.0);
	dir.x *= compute_uniform.u.aspect;
	dir.z = 1.0 / tan(compute_uniform.u.fovy * PI / 360.0f);
	dir = normalize(dir) * -1 * compute_uniform.u.rotation;
	vec2 intr_uv;
	vec2 tex_uv;
	uint debug = 0;

	vec4 color = vec4(uv, 0.0, 1.0);
	ivec2 dst = size - ivec2(gl_GlobalInvocationID.xy);

	vec4 position = vec4(0, 0, 0, 1) - compute_uniform.u.translation;

	for (uint n = 0; n < nodes.length(); n++) {
		uint m = nodes[n].mesh_id;
		vec2 uv;
		uint id = nodes[n].node_id;
		if (intersect_mesh(position.xyz - nodes[n].position, dir.xyz, m, debug, uv)) {
			color.xy = uv;
			/*MATERIAL_CALLS*/
		}
	}
	//color.x += debug / 1000.0f;
	color.a = 1.0;
	imageStore(result, dst, color);
}
